// just goofing around with some of the easy details

#include <Arduino.h>

#include <Bounce2.h>

Bounce bypass_switch_A = Bounce();
Bounce bypass_switch_B = Bounce();

const uint16_t DEBOUNCE_TIME = 25;

bool A_is_bypassed = false;
bool B_is_bypassed = false;

#include "LFO.h"

const double sample_rate = 3e3;

const uint32_t sample_period_in_microseconds = (1 / sample_rate) * 10e5;

uint32_t last_tick = 0;

LFO LFO_A(sample_rate);
LFO LFO_B(sample_rate);

#include "FastLED.h"

const int NUM_LEDS = 2;
CRGB led[NUM_LEDS];

enum LED
{
    A = 0,
    B = 1
};

#include "MCP4822.h"

const int CS_1_PIN = 15;
const int CS_2_PIN = 9;

MCP4822 dac_1(CS_1_PIN, MCP4822::Full_Scale_Output::TWO_POINT_ZERO_FOUR_EIGHT_VOLTS);
MCP4822 dac_2(CS_2_PIN, MCP4822::Full_Scale_Output::TWO_POINT_ZERO_FOUR_EIGHT_VOLTS);

#include "CD74HC4067.h"

const int MUX_S0 = 20;
const int MUX_S1 = 19;
const int MUX_S2 = 22;
const int MUX_S3 = 23;
const int MUX_COM = A7;

CD74HC4067 mux(MUX_S0, MUX_S1, MUX_S2, MUX_S3, MUX_COM);

enum CV_SOURCE
{
    // in order according to physical routing of the mux on the PCB
    // see schematic for details
    RATE_A = 0,
    DEPTH_A = 1,
    SHAPE_A = 2,
    ENV_LEVEL_A = 3,
    REZ_A = 4,
    RATE_B = 13,
    DEPTH_B = 12,
    SHAPE_B = 7,
    ENV_LEVEL_B = 6,
    REZ_B = 5,
    MANUAL_FREQ = 14,
    SEPARATION = 15,
    ENV_A = 11,
    ENV_B = 10,
    FREQ_CV = 9,
    RATE_CV = 8
};

enum SWEEP_MODE
{
    NORMAL,
    SYNC_TO_A,
    ADD
};

SWEEP_MODE sweep_mode = SWEEP_MODE::NORMAL;

bool B_is_inverted = false;

const int FOOTSWITCH_A_PIN = 3;
const int FOOTSWITCH_B_PIN = 4;

const int BYPASS_A_PIN = 18;
const int BYPASS_B_PIN = 17;

const int INVERT_B_SW_PIN = 6;
const int SWEEP_MODE_SW1_PIN = 7;
const int SWEEP_MODE_SW2_PIN = 8;

const int LED_SERIAL_PIN = 5;

const int FULL_SCALE = 0x0FFF; // for 12 bit DACs
const int HALF_SCALE = 0x07FF;

#include <array>

const int NUM_LFO_RATE_LUT_POINTS = 1 << 8;
const double APPROX_MAX_LFO_FREQ = 10.0;
const double APPROX_MIN_LFO_FREQ = 0.05;

// const lut generated by immediately-invoked lambda
const std::array<double, NUM_LFO_RATE_LUT_POINTS> LFO_rate_lut = []
{
    std::array<double, NUM_LFO_RATE_LUT_POINTS> arr;

    for (int i = 0; i < NUM_LFO_RATE_LUT_POINTS; i++)
    {
        double x = i;
        x = pow(x, 2);
        double squish_factor = pow(NUM_LFO_RATE_LUT_POINTS, 2) / APPROX_MAX_LFO_FREQ;
        x /= squish_factor;
        arr[i] = x + APPROX_MIN_LFO_FREQ; // small positive offset so rate is never zero
    }

    return arr;
}();

int32_t clampForDac(int32_t x);

void handleLFO_A_frequency();
void handleLFO_B_frequency();

int32_t getBipolarCVsource(CV_SOURCE source);
int32_t getUnipolarCVsource(CV_SOURCE source);

void setLEDtoRainbowFromCV(CRGB &led, int32_t CV);
void setLEDoff(CRGB &led);

void setup()
{

    analogReadResolution(12);

    bypass_switch_A.attach(BYPASS_A_PIN, INPUT_PULLUP);
    bypass_switch_B.attach(BYPASS_B_PIN, INPUT_PULLUP);
    bypass_switch_A.interval(DEBOUNCE_TIME);
    bypass_switch_B.interval(DEBOUNCE_TIME);

    pinMode(FOOTSWITCH_A_PIN, INPUT_PULLUP);
    pinMode(FOOTSWITCH_B_PIN, INPUT_PULLUP);

    pinMode(BYPASS_A_PIN, OUTPUT);
    pinMode(BYPASS_B_PIN, OUTPUT);

    pinMode(INVERT_B_SW_PIN, INPUT_PULLUP);

    pinMode(SWEEP_MODE_SW1_PIN, INPUT_PULLUP);
    pinMode(SWEEP_MODE_SW2_PIN, INPUT_PULLUP);

    pinMode(LED_SERIAL_PIN, OUTPUT);

    FastLED.addLeds<NEOPIXEL, LED_SERIAL_PIN>(led, NUM_LEDS);

    digitalWrite(BYPASS_A_PIN, HIGH);
    digitalWrite(BYPASS_B_PIN, HIGH);
}

void loop()
{
    if ((micros() - last_tick) > sample_period_in_microseconds)
    {
        last_tick = micros();

        bypass_switch_A.update();
        bypass_switch_B.update();

        if (bypass_switch_A.fell())
        {
            A_is_bypassed = !A_is_bypassed;
            digitalWrite(BYPASS_A_PIN, A_is_bypassed);
        }

        if (bypass_switch_B.fell())
        {
            B_is_bypassed = !B_is_bypassed;
            digitalWrite(BYPASS_B_PIN, B_is_bypassed);
        }

        if (digitalRead(SWEEP_MODE_SW1_PIN) && !digitalRead(SWEEP_MODE_SW2_PIN))
        {
            sweep_mode = SWEEP_MODE::NORMAL;
        }
        else if (digitalRead(SWEEP_MODE_SW1_PIN) && digitalRead(SWEEP_MODE_SW2_PIN))
        {
            sweep_mode = SWEEP_MODE::SYNC_TO_A;
        }
        else
        {
            sweep_mode = SWEEP_MODE::ADD;
        }

        B_is_inverted = !digitalRead(INVERT_B_SW_PIN);

        handleLFO_A_frequency();
        handleLFO_B_frequency();

        LFO_A.tick();
        LFO_B.tick();

        int32_t manual_freq = getBipolarCVsource(CV_SOURCE::MANUAL_FREQ);
        int32_t separation = getBipolarCVsource(CV_SOURCE::SEPARATION) >> 1;

        double lfo_A_scanner_position = (double)getUnipolarCVsource(CV_SOURCE::SHAPE_A) / FULL_SCALE;
        double lfo_B_scanner_position = (double)getUnipolarCVsource(CV_SOURCE::SHAPE_B) / FULL_SCALE;

        int32_t lfo_A = (LFO_A.getOutput(lfo_A_scanner_position) + 1.0) * ((2 << 10) - 1) - HALF_SCALE;
        int32_t depth_A = getUnipolarCVsource(CV_SOURCE::DEPTH_A);
        int32_t lfo_B = (LFO_B.getOutput(lfo_B_scanner_position) + 1.0) * ((2 << 10) - 1) - HALF_SCALE;
        int32_t depth_B = getUnipolarCVsource(CV_SOURCE::DEPTH_B);

        int32_t CV_A = 0;
        int32_t CV_B = 0;

        CV_A += manual_freq;
        CV_B += manual_freq;
        CV_A -= separation;
        CV_B += separation;

        if (sweep_mode == SWEEP_MODE::NORMAL)
        {
            // filter A gets LFO A
            CV_A += (lfo_A * depth_A) / FULL_SCALE;

            // filter B gets inverted or non-inverted LFO B
            if (B_is_inverted)
            {
                CV_B -= (lfo_B * depth_B) / FULL_SCALE;
            }
            else
            {
                CV_B += (lfo_B * depth_B) / FULL_SCALE;
            }
        }
        else if (sweep_mode == SWEEP_MODE::SYNC_TO_A)
        {
            // filter A gets LFO A
            CV_A += (lfo_A * depth_A) / FULL_SCALE;

            // filter B gets inverted or non-inverted LFO A
            if (B_is_inverted)
            {
                CV_B -= (lfo_A * depth_B) / FULL_SCALE;
            }
            else
            {
                CV_B += (lfo_A * depth_B) / FULL_SCALE;
            }
        }
        else if (sweep_mode == SWEEP_MODE::ADD)
        {
            int32_t lfo_A_contrib = (lfo_A * depth_A) / FULL_SCALE;
            int32_t lfo_B_contrib = (lfo_B * depth_B) / FULL_SCALE;

            // filter A gets LFO A plus LFO B
            CV_A += lfo_A_contrib;
            CV_A += lfo_B_contrib;

            // filter B gets LFO B plus inverted or non-inverted LFO A
            CV_B += lfo_B_contrib;

            if (B_is_inverted)
            {
                CV_B -= lfo_A_contrib;
            }
            else
            {
                CV_B += lfo_A_contrib;
            }
        }

        int32_t env_A = getBipolarCVsource(CV_SOURCE::ENV_A);
        env_A *= getBipolarCVsource(CV_SOURCE::ENV_LEVEL_A);
        env_A /= HALF_SCALE;
        CV_A -= env_A;

        int32_t env_B = getBipolarCVsource(CV_SOURCE::ENV_B);
        env_B *= getBipolarCVsource(CV_SOURCE::ENV_LEVEL_B);
        env_B /= HALF_SCALE;
        CV_B -= env_B;

        CV_A = clampForDac(CV_A + HALF_SCALE);
        CV_B = clampForDac(CV_B + HALF_SCALE);

        dac_1.setOutput(MCP4822::Channel::A, CV_A);
        dac_1.setOutput(MCP4822::Channel::B, getUnipolarCVsource(CV_SOURCE::REZ_A));

        dac_2.setOutput(MCP4822::Channel::A, CV_B);
        dac_2.setOutput(MCP4822::Channel::B, getUnipolarCVsource(CV_SOURCE::REZ_B));

        if (A_is_bypassed)
        {
            setLEDoff(led[LED::A]);
        }
        else
        {
            setLEDtoRainbowFromCV(led[LED::A], CV_A);
        }

        if (B_is_bypassed)
        {
            setLEDoff(led[LED::B]);
        }
        else
        {
            setLEDtoRainbowFromCV(led[LED::B], CV_B);
        }
    }

    EVERY_N_MILLISECONDS(20)
    {
        FastLED.show();
    }
}

int32_t clampForDac(int32_t x)
{
    if (x < 0)
    {
        return 0;
    }
    else if (x > FULL_SCALE)
    {
        return FULL_SCALE;
    }
    else
    {
        return x;
    }
}

int32_t getBipolarCVsource(CV_SOURCE source)
{
    mux.select(source);
    int32_t CV = (FULL_SCALE - mux.analogReadCom());
    CV -= HALF_SCALE;
    return CV;
}

int32_t getUnipolarCVsource(CV_SOURCE source)
{
    mux.select(source);
    return FULL_SCALE - mux.analogReadCom();
}

void setLEDtoRainbowFromCV(CRGB &led, int32_t CV)
{
    led = CHSV(((CV / 18) + 130) % 256 , 225, 50);
}

void setLEDoff(CRGB &led)
{
    led = CRGB::Black;
}

void handleLFO_A_frequency()
{
    double rate_a = LFO_rate_lut[getUnipolarCVsource(CV_SOURCE::RATE_A) >> 4];
    LFO_A.setFrequency(rate_a);
}

void handleLFO_B_frequency()
{
    double rate_b = LFO_rate_lut[getUnipolarCVsource(CV_SOURCE::RATE_B) >> 4];
    LFO_B.setFrequency(rate_b);
}
